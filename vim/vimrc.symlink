" .vimrc
" Author: Andrew Stewart <andrew@averagestudios.com>
" Source: https://github.com/stewart/dotfiles/tree/master/vim

" Preamble ---------------------------------------------------------------- {{{

filetype off
call pathogen#infect()
filetype plugin indent on
set nocompatible

" }}}
" Basic options ----------------------------------------------------------- {{{
"
set noai
set nosi
set autoread
set autowrite
set backspace=indent,eol,start
set backupskip=/tmp/*,/private/tmp/*"
set colorcolumn=80
set completeopt=longest,menuone,preview
set complete=.,w,b,u,t
set clipboard=unnamed
set encoding=utf-8
set exrc
set fillchars=diff:⣿,vert:│
set hidden
set history=1000
set laststatus=2
set lazyredraw
set linebreak
set list
set listchars=tab:▸\ ,trail:⋅,extends:❯,precedes:❮
set matchtime=3
set modelines=0
set noerrorbells
set noshowcmd
set notimeout
set novisualbell
set number
set relativenumber
set ruler
set shiftround
set showbreak=↪
set sidescroll=1
set sidescrolloff=10
set dictionary=/usr/share/dict/words
set spellfile=~/.vim/custom-dictionary.utf-8.add
set splitbelow
set splitright
set synmaxcol=800
set title
set ttimeout
set ttimeoutlen=10
set ttyfast
set undofile
set undoreload=10000
set virtualedit+=block
set mouse=a
set t_ti= t_te=   " makes vim play nice with terminal scrollback

" Save when losing focus
au FocusLost * :silent! wall

" Resize splits when the window is resized
au VimResized * :wincmd =

" Wildmenu completion {{{

set wildmenu
set wildmode=list:longest,full

set wildignore+=.hg,.git,.svn
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest
set wildignore+=*.spl
set wildignore+=*.DS_Store

set wildignore+=migrations
set wildignore+=*.pyc

set wildignore+=classes
set wildignore+=lib

" }}}
" Line Return {{{

augroup line_return
    au!
    au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \     execute 'normal! g`"zvzz' |
        \ endif
augroup END

" }}}
" Tabs, spaces, wrapping {{{

set tabstop=2
set shiftwidth=2
set softtabstop=2
set expandtab
set nosmarttab
set textwidth=80
set formatoptions=qrn1
set nowrap
set whichwrap+=<,>,h,l,[,]      " backspace and cursor keys wrap to

" }}}
" Relative Line Numbers in Current Buffer {{{

fun! SetRelativeNumberInBuffer()
  if &ft =~ 'nerdtree'
    setlocal norelativenumber
    return
  endif
  setlocal relativenumber
endfun

fun! SetNumberInBuffer()
  if &ft =~ 'nerdtree'
    setlocal nonumber
    return
  endif
  setlocal number
endfun

if exists('&relativenumber')
  set relativenumber

  if &ft =~ 'nerdtree'
    set norelativenumber
  end

  augroup WindowRNU
    auto!
    auto BufWinEnter,WinEnter,FocusGained * call SetRelativeNumberInBuffer()
    auto WinLeave,FocusLost               * call SetNumberInBuffer()
  augroup END
endif

" }}}
" Backups {{{

set backup
set noswapfile

set undodir=~/.vim/tmp/undo//
set backupdir=~/.vim/tmp/backup//
set directory=~/.vim/tmp/swap//

" Make those folders automatically if they don't already exist.
if !isdirectory(expand(&undodir))
    call mkdir(expand(&undodir), "p")
endif
if !isdirectory(expand(&backupdir))
    call mkdir(expand(&backupdir), "p")
endif
if !isdirectory(expand(&directory))
    call mkdir(expand(&directory), "p")
endif

" }}}
" Leader {{{

let mapleader = ","
let maplocalleader = "\\"

" }}}
" Colorscheme Font, and Guioptions {{{

let g:solarized_termcolors=16
colorscheme solarized
set background=dark
set guifont=Inconsolata-dz\ for\ PowerLine:h12
set guioptions-=T
set guioptions-=m
set guioptions=aAce
syntax on

" }}}
"
" }}}
" Convenience mappings ---------------------------------------------------- {{{

" exit to normal mode with 'jj'
inoremap jj <ESC>

nnoremap <leader>` :set cursorline!<cr>:set cursorcolumn!<cr>

" Sort lines
vnoremap <leader>s :!sort<cr>

" Tabs
nnoremap <leader>( :tabprev<cr>
nnoremap <leader>) :tabnext<cr>

" Get filename quickly
nnoremap <leader>f :silent let @*=@%

nnoremap ; :
vnoremap ; :

" gundo
nnoremap <Leader>u :GundoToggle<CR>

" keep the cursor in place while joining lines
nnoremap J mzJ`z

" split line
nnoremap S i<cr><esc>^mwgk:silent! s/\v +$//<cr>:noh<cr>`w 
" Set newline commands to return to insert mode
nmap o o<Esc>
nmap O O<Esc>

" Change window splits easily
map <C-J> <C-w><C-j>
map <C-K> <C-w><C-k>
map <C-h> <C-w><C-h>
map <C-l> <C-w><C-l>

" Write as sudo
cmap w!! %!sudo tee > /dev/null %

" Shortcut to previous file
map <leader><leader> <c-^>

" Shortcut to run current rspec file
map <leader>rt :call RunTestFile()<cr>
map <leader>rT :call RunNearestTest()<cr>
map <leader>ra :call RunTests('')<cr>

" Use space key to toggle folds
nnoremap <Space> za
vnoremap <Space> za

" Emacs bindings in command line mode
cnoremap <c-a> <home>
cnoremap <c-e> <end>

" Open Markdown previews in Marked.app
nnoremap <leader>m :silent !open -a Marked.app '%:p'<cr>

" Make finding marks easier
noremap ' `

" Go to beginning or end of line
nnoremap H ^
nnoremap L g_

" Clear trailing whitespace
nnoremap <leader>w mz:%s/\s\+$//<cr>:let @/=''<cr>`z

" sane movement with wrap turned on
nnoremap <silent> j gj
nnoremap <silent> k gk
vnoremap <silent> j gj
vnoremap <silent> k gk

" Alternate between two and four space indentation
nnoremap <leader>2 :setlocal shiftwidth=2 tabstop=2 softtabstop=2<cr>
nnoremap <leader>4 :setlocal shiftwidth=4 tabstop=4 softtabstop=4<cr>

" Select all
nnoremap vaa ggvGg_
nnoremap Vaa ggVG

" sjl's uppercase word mapping
inoremap <C-u> <esc>mzgUiw`za

" Easier to press
nnoremap <tab> %
vnoremap <tab> %

" Reformat line.
nnoremap ql gqq

" Shortcut to rename current file
map <leader>r :call RenameFile()<cr>

" Make Y behave like other capitals
nnoremap Y y$

" fix linewise visual selection of various text objects
nnoremap VV V
nnoremap Vit vitVkoj
nnoremap Vat vatV
nnoremap Vab vabV
nnoremap VaB vaBV

" made D behave
nnoremap D d$

noremap <leader>v <C-w>v

" Formatting, TextMate-style
nnoremap Q gqip
vnoremap Q gq

" Easy filetype switching {{{
nnoremap _md   :set ft=markdown<CR>
nnoremap _php  :set ft=php<CR>
nnoremap _js   :set ft=javascript<CR>
nnoremap _html :set ft=html<CR>
nnoremap _erb  :set ft=eruby<CR>
nnoremap _rb   :set ft=ruby<CR>
nnoremap _v    :set ft=vim<CR>

" }}}
" Insert Mode Completion {{{

inoremap <c-f> <c-x><c-f>
inoremap <c-]> <c-x><c-]>

" }}}
" BufferOnly {{{

command! -nargs=? -complete=buffer -bang Bonly
    \ :call BufOnly('<args>', '<bang>')
command! -nargs=? -complete=buffer -bang BOnly
    \ :call BufOnly('<args>', '<bang>')
command! -nargs=? -complete=buffer -bang Bufonly
    \ :call BufOnly('<args>', '<bang>')
command! -nargs=? -complete=buffer -bang BufOnly
    \ :call BufOnly('<args>', '<bang>')

" }}}

" }}}
" Quick editing ----------------------------------------------------------- {{{

nnoremap <leader>ev :vsplit $MYVIMRC<cr>
nnoremap <leader>ed :vsplit ~/.vim/custom-dictionary.utf-8.add<cr>
nnoremap <leader>eg :vsplit ~/.gitconfig<cr>
nnoremap <leader>ez :vsplit ~/.zshrc<cr>
nnoremap <leader>et :vsplit ~/.tmux.conf<cr>

" }}}
" Searching and movement -------------------------------------------------- {{{

set ignorecase
set smartcase
set incsearch
set showmatch
set hlsearch
set gdefault

" Centers search results
map N Nzz
map n nzz

" Clear search buffer on return
nnoremap <CR> :nohlsearch<cr>

" }}}
" Folding ----------------------------------------------------------------- {{{

set foldlevelstart=0

" Space to toggle folds.
nnoremap <Space> za
vnoremap <Space> za

" Make zO recursively open whatever top level fold we're in, no matter where the
" cursor happens to be.
nnoremap zO zCzO

function! MyFoldText() " {{{
    let line = getline(v:foldstart)

    let nucolwidth = &fdc + &number * &numberwidth
    let windowwidth = winwidth(0) - nucolwidth - 3
    let foldedlinecount = v:foldend - v:foldstart

    " expand tabs into spaces
    let onetab = strpart('          ', 0, &tabstop)
    let line = substitute(line, '\t', onetab, 'g')

    let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
    let fillcharcount = windowwidth - len(line) - len(foldedlinecount)
    return line . '…' . repeat(" ",fillcharcount) . foldedlinecount . '…' . ' '
endfunction " }}}
set foldtext=MyFoldText()

" }}}
" Filetype-specific ------------------------------------------------------- {{{

" andrew-stewart.ca blog entries {{{

augroup ft_andrewstewartca
    au!
    au BufRead,BufNewFile */blog/source/_posts/*.md set spell
augroup END

" }}}
" Clojure {{{

augroup ft_clojure
    au!
    set wildignore+=classes
    set wildignore+=lib

    au FileType clojure silent! call TurnOnClojureFolding()
augroup END

" }}}
" CSS {{{

augroup ft_css
    au!

    au FileType css,scss setlocal foldmethod=marker
    au FileType css,scss setlocal foldmarker={,}


    " Use <leader>S to sort properties.  Turns this:
    "
    "     p {
    "         width: 200px;
    "         height: 100px;
    "         background: red;
    "         ...
    "     }
    "
    " into this:
    "
    "     p {
    "         background: red;
    "         height: 100px;
    "         width: 200px;
    "         ...
    "     }
    au BufNewFile,BufRead *.scss,*.css nnoremap <buffer> <localleader>S ?{<CR>jV/\v^\s*\}?$<CR>k:sort<CR>:noh<CR>
augroup END

" }}}
" Javascript {{{

augroup ft_javascript
    au!

    au FileType javascript setlocal foldmethod=marker
    au FileType javascript setlocal foldmarker={,}

    " Make {<cr> insert a pair of brackets in such a way that the cursor is correctly
    " positioned inside of them AND the following code doesn't get unfolded.
    au Filetype javascript inoremap <buffer> {<cr> {}<left><cr><space><space>.<cr><esc>kA<bs>
augroup END

" }}}
" Markdown {{{

augroup ft_markdown
    au!

    au BufNewFile,BufRead *.md,*.markdown setlocal filetype=markdown
    au BufNewFile,BufRead *.md,*.markdown setlocal textwidth=80
    au BufNewFile,BufRead *.md,*.markdown setlocal syntax=off

    " Use <localleader>1/2/3 to add headings.
    au Filetype markdown nnoremap <buffer> <localleader>1 yypVr=
    au Filetype markdown nnoremap <buffer> <localleader>2 yypVr-
    au Filetype markdown nnoremap <buffer> <localleader>3 I### <ESC>
augroup END
" }}}
" PHP {{{

augroup ft_php
    au!

    au FileType php,phtml setlocal foldmethod=marker
    au FileType php,phtml setlocal foldmarker={,}
    au FileType php,phtml setlocal makeprg=php\ -l\ %
    au FileType php,phtml setlocal errorformat=%m\ in\ %f\ on\ line\ %l
augroup END

" }}}
" Python {{{

augroup ft_python
    au!

    au Filetype python setlocal tabstop=4 shiftwidth=4 softtabstop=4
    au FileType python setlocal foldmethod=indent
augroup END

" }}}
" Vim {{{

augroup ft_vim
    au!

    au FileType vim setlocal foldmethod=marker
    au FileType vim setlocal textwidth=80
    au FileType help setlocal textwidth=78
    au BufWinEnter *.txt if &ft == 'help' | wincmd L | endif
augroup END

" }}}

" }}}
" Plugin settings --------------------------------------------------------- {{{

" Ctrl-P {{{

let g:ctrlp_dont_split = 'NERD_tree_2'
let g:ctrlp_jump_to_buffer = 0
let g:ctrlp_map = '<Leader>t'
let g:ctrlp_max_files = 10000
let g:ctrlp_working_path_mode = 0
let g:ctrlp_match_window_reversed = 1
let g:ctrlp_split_window = 0
let g:ctrlp_max_height = 20
let g:ctrlp_extensions = ['tag']

" Easier mappings for searches
nnoremap <leader>gl :CtrlP lib/<cr>
nnoremap <leader>gt :CtrlP test/<cr>
nnoremap <leader>gs :CtrlP spec/<cr>
nnoremap <leader>gf :CtrlP features/<cr>
nnoremap <leader>gd :CtrlP db/<cr>
nnoremap <leader>ga :CtrlP app/assets/<cr>
nnoremap <leader>gm :CtrlP app/models/<cr>
nnoremap <leader>gc :CtrlP app/controllers/<cr>
nnoremap <leader>gv :CtrlP app/views/<cr>
nnoremap <leader>gb :CtrlPBufTag<cr>

let g:ctrlp_prompt_mappings = {
\ 'PrtSelectMove("j")':   ['<c-j>', '<down>', '<s-tab>'],
\ 'PrtSelectMove("k")':   ['<c-k>', '<up>', '<tab>'],
\ 'PrtHistory(-1)':       ['<c-n>'],
\ 'PrtHistory(1)':        ['<c-p>'],
\ 'ToggleFocus()':        ['<c-tab>'],
\ }

let ctrlp_filter_greps = "".
    \ "egrep -iv '\\.(" .
    \ "jar|class|swp|swo|log|so|o|pyc|jpe?g|png|gif|mo|po" .
    \ ")$' | " .
    \ "egrep -v '^(\\./)?(" .
    \ "deploy/|lib/|classes/|libs/|deploy/vendor/|.git/|.hg/|.svn/|.*migrations/|docs/build/|vendor/bundle" .
    \ ")'"

let my_ctrlp_user_command = "" .
    \ "find %s '(' -type f -or -type l ')' -maxdepth 15 -not -path '*/\\.*/*' | " .
    \ ctrlp_filter_greps

let g:ctrlp_user_command = my_ctrlp_user_command

nnoremap <leader>. :CtrlPTag<cr>

" }}}
" NERDTree {{{

map <Leader>n :NERDTree<CR>

let NERDTreeHighlightCursorline = 1
let NERDTreeIgnore = ['.vim$', '\~$', '.*\.pyc$', 'pip-log\.txt$', 'whoosh_index',
                    \ 'xapian_index', '.*.pid', 'monitor.py', '.*-fixtures-.*.json',
                    \ '.*\.o$', 'db.db', 'tags.bak']

let NERDTreeShowHidden=0
let NERDTreeIgnore=['\.rbc$', '\~$']
let NERDTreeMinimalUI = 1
let NERDTreeDirArrows = 1
let NERDChristmasTree = 1

" }}}
" Airline {{{

let g:airline_powerline_fonts = 1

" }}}
" Scratch {{{

command! ScratchToggle call ScratchToggle()

function! ScratchToggle()
    if exists("w:is_scratch_window")
        unlet w:is_scratch_window
        exec "q"
    else
        exec "normal! :Sscratch\<cr>\<C-W>L"
        let w:is_scratch_window = 1
    endif
endfunction

nnoremap <silent> <leader>s :ScratchToggle<cr>

" }}}
"" Supertab {{{

let g:SuperTabDefaultCompletionType = "<c-n>"
let g:SuperTabLongestHighlight = 1
let g:SuperTabCrMapping = 1

"}}}
" LustyJuggler {{{

let g:LustyJugglerAltTabMode = 1
let g:LustyJugglerSuppressRubyWarning = 1
noremap <silent> <Leader><Tab> :LustyJuggler<CR>

" }}}
" T-Comment {{{

map <Leader>c <c-_><c-_>

"}}}
" Rails.vim {{{

" Projections
  let g:rails_projections = {
  \ "app/services/*.rb": {
  \   "command": "service",
  \   "template": "class %S\nend",
  \   "test": [
  \     "test/service/%s_test.rb",
  \     "spec/service/%s_spec.rb"
  \   ]
  \ },
  \ "spec/fabricators/*_fabricator.rb": {
  \   "command": "fabricator",
  \   "template": "Fabricator(:%s)\nend",
  \   "keywords": "sequence",
  \   "affinity": "model"
  \ },
  \ "features/support/*.rb": {"command": "support"},
  \ "features/support/env.rb": {"command": "support"}}

" }}}

" }}}
" Text objects ------------------------------------------------------------ {{{

" Shortcut for [] {{{

onoremap ir i[
onoremap ar a[
vnoremap ir i[
vnoremap ar a[

" }}}
" Numbers {{{

" Motion for numbers.  Great for CSS.  Lets you do things like this:
"
" margin-top: 200px; -> daN -> margin-top: px;
"              ^                          ^
" TODO: Handle floats.

onoremap N :<c-u>call <SID>NumberTextObject(0)<cr>
xnoremap N :<c-u>call <SID>NumberTextObject(0)<cr>
onoremap aN :<c-u>call <SID>NumberTextObject(1)<cr>
xnoremap aN :<c-u>call <SID>NumberTextObject(1)<cr>
onoremap iN :<c-u>call <SID>NumberTextObject(1)<cr>
xnoremap iN :<c-u>call <SID>NumberTextObject(1)<cr>

function! s:NumberTextObject(whole)
    normal! v

    while getline('.')[col('.')] =~# '\v[0-9]'
        normal! l
    endwhile

    if a:whole
        normal! o

        while col('.') > 1 && getline('.')[col('.') - 2] =~# '\v[0-9]'
            normal! h
        endwhile
    endif
endfunction

" }}}

" }}}
" Functions--------------------------------------------------------- {{{

function! s:CopyMotionForType(type) " {{{
    if a:type ==# 'v'
        silent execute "normal! `<" . a:type . "`>y"
    elseif a:type ==# 'char'
        silent execute "normal! `[v`]y"
    endif
endfunction " }}}
function! BufOnly(buffer, bang) " {{{
  if a:buffer == ''
    " No buffer provided, use the current buffer.
    let buffer = bufnr('%')
  elseif (a:buffer + 0) > 0
    " A buffer number was provided.
    let buffer = bufnr(a:buffer + 0)
  else
    " A buffer name was provided.
    let buffer = bufnr(a:buffer)
  endif

  if buffer == -1
    echohl ErrorMsg
    echomsg "No matching buffer for" a:buffer
    echohl None
    return
  endif

  let last_buffer = bufnr('$')

  let delete_count = 0
  let n = 1
  while n <= last_buffer
    if n != buffer && buflisted(n)
      if a:bang == '' && getbufvar(n, '&modified')
        echohl ErrorMsg
        echomsg 'No write since last change for buffer'
              \ n '(add ! to override)'
        echohl None
      else
        silent exe 'bdel' . a:bang . ' ' . n
        if ! buflisted(n)
          let delete_count = delete_count+1
        endif
      endif
    endif
    let n = n+1
  endwhile

  if delete_count == 1
    echomsg delete_count "buffer deleted"
  elseif delete_count > 1
    echomsg delete_count "buffers deleted"
  endif

endfunction " }}}
function! GetClojureFold() " {{{
      if getline(v:lnum) =~ '^\s*(defn.*\s'
            return ">1"
      elseif getline(v:lnum) =~ '^\s*(defmacro.*\s'
            return ">1"
      elseif getline(v:lnum) =~ '^\s*(defmethod.*\s'
            return ">1"
      elseif getline(v:lnum) =~ '^\s*$'
            let my_cljnum = v:lnum
            let my_cljmax = line("$")

            while (1)
                  let my_cljnum = my_cljnum + 1
                  if my_cljnum > my_cljmax
                        return "<1"
                  endif

                  let my_cljdata = getline(my_cljnum)

                  " If we match an empty line, stop folding
                  if my_cljdata =~ '^$'
                        return "<1"
                  else
                        return "="
                  endif
            endwhile
      else
            return "="
      endif
endfunction " }}}
function! TurnOnClojureFolding() " {{{
      setlocal foldexpr=GetClojureFold()
      setlocal foldmethod=expr
endfunction " }}}
function! RenameFile() " {{{
    let old_name = expand('%')
    let new_name = input('New file name: ', expand('%'), 'file')
    if new_name != '' && new_name != old_name
        exec ':saveas ' . new_name
        exec ':silent !rm ' . old_name
        redraw!
    endif
endfunction " }}}
function! RunTestFile(...) " {{{
    if a:0
        let command_suffix = a:1
    else
        let command_suffix = ""
    endif

    " Run the tests for the previously-marked file.
    let in_test_file = match(expand("%"), '\(.feature\|_spec.rb\)$') != -1
    if in_test_file
        call SetTestFile()
    elseif !exists("t:current_test_file")
        return
    end
    call RunTests(t:current_test_file . command_suffix)
endfunction " }}}
function! RunNearestTest() " {{{
    let spec_line_number = line('.')
    call RunTestFile(":" . spec_line_number . " -b")
endfunction " }}}
function! SetTestFile() " {{{
    " Set the spec file that tests will be run for.
    let t:current_test_file=@%
endfunction " }}}
function! RunTests(filename) " {{{
    " Write the file and run tests for the given filename
    :w
    if match(a:filename, '\.feature$') != -1
        exec ":!script/features " . a:filename
    else
        if filereadable("script/test")
            exec ":!script/test " . a:filename
        elseif filereadable("Gemfile")
            exec ":!bundle exec rspec " . a:filename
        else
            exec ":!rspec " . a:filename
        end
    end
endfunction " }}}

" }}}

" Prevent project vimrc files from damaging stuff
set secure
