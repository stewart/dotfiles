" .vimrc
" Author: Andrew Stewart <andrew@stwrt.ca>
" Source: https://github.com/stewart/dotfiles/tree/master/vim

" Preamble ---------------------------------------------------------------- {{{

filetype off
call pathogen#infect()
filetype plugin indent on
set nocompatible

" }}}
" Statusline --------------------------------------------------------------- {{{

set statusline=%<%f\ (%{&ft})\ %-4(%m%)%=%-19(%3l,%02c%03V%)

" }}}
" Basic options ----------------------------------------------------------- {{{
"
set noai
set nosi
set autoread
set autowrite
set backspace=indent,eol,start
set backupskip=/tmp/*,/private/tmp/*"
set colorcolumn=80
set completeopt=longest,menuone,preview
set complete=.,w,b,u,t
set clipboard=unnamed
set encoding=utf-8
set exrc
set fillchars=diff:⣿,vert:│
set hidden
set history=1000
set nojoinspaces
set laststatus=2
set lazyredraw
set linebreak
set list
set listchars=tab:▸\ ,trail:⋅,extends:❯,precedes:❮
set matchtime=3
set modelines=0
set noerrorbells
set noshowcmd
set notimeout
set novisualbell
set number
set relativenumber
set ruler
set shiftround
set showbreak=↪
set sidescroll=1
set sidescrolloff=10
set showtabline=2
set dictionary=/usr/share/dict/words
set spellfile=~/.vim/custom-dictionary.utf-8.add
set splitbelow
set splitright
set synmaxcol=800
set switchbuf=useopen
set title
set ttimeout
set ttimeoutlen=10
set ttyfast
set undofile
set undoreload=10000
set virtualedit+=block
set mouse=a
set t_ti= t_te=   " makes vim play nice with terminal scrollback

" Resize splits when the window is resized
au VimResized * :wincmd =

" Wildmenu completion {{{

set wildmenu
set wildmode=list:longest,full

set wildignore+=.hg,.git,.svn
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest
set wildignore+=*.spl
set wildignore+=*.DS_Store

set wildignore+=migrations
set wildignore+=*.pyc

set wildignore+=classes
set wildignore+=lib

" }}}
" Line Return {{{

augroup line_return
    au!
    autocmd BufReadPost *
      \ if line("'\"") > 0 && line("'\"") <= line("$") |
      \   exe "normal g`\"" |
      \ endif

augroup END

" }}}
" Tabs, spaces, wrapping {{{

set tabstop=2
set shiftwidth=2
set softtabstop=2
set expandtab
set nosmarttab
set textwidth=80
set formatoptions=qrn1j
set nowrap
set whichwrap+=<,>,h,l,[,]      " backspace and cursor keys wrap to

" }}}
" Relative Line Numbers in Current Buffer {{{

fun! SetRelativeNumberInBuffer()
  setlocal relativenumber
endfun

fun! SetNumberInBuffer()
  setlocal number
endfun

if exists('&relativenumber')
  set relativenumber

  augroup WindowRNU
    auto!
    auto BufWinEnter,WinEnter,FocusGained * call SetRelativeNumberInBuffer()
    auto WinLeave,FocusLost               * call SetNumberInBuffer()
  augroup END
endif

" }}}
" Backups {{{

set backup
set noswapfile

set undodir=~/.vim/tmp/undo//
set backupdir=~/.vim/tmp/backup//
set directory=~/.vim/tmp/swap//

" Make those folders automatically if they don't already exist.
if !isdirectory(expand(&undodir))
    call mkdir(expand(&undodir), "p")
endif
if !isdirectory(expand(&backupdir))
    call mkdir(expand(&backupdir), "p")
endif
if !isdirectory(expand(&directory))
    call mkdir(expand(&directory), "p")
endif

" }}}
" Leader {{{

let mapleader = ","
let maplocalleader = "\\"

" }}}
" Colorscheme Font, and Guioptions {{{

colorscheme dark
set background=dark
set guifont=Inconsolata-dz\ for\ PowerLine:h12
set guioptions-=T
set guioptions-=m
set guioptions=aAce
syntax on

" }}}
"
" }}}
" Convenience mappings ---------------------------------------------------- {{{

" exit to normal mode with 'jj'
inoremap jj <ESC>

" Select last pasted text
nnoremap <expr> gp '`[' . strpart(getregtype(), 0, 1) . '`]'

nnoremap <leader>` :set cursorline!<cr>:set cursorcolumn!<cr>

" Gundo
nnoremap <Leader>u :GundoToggle<CR>

" keep the cursor in place while joining lines
nnoremap J mzJ`z

" split line
nnoremap S i<cr><esc>^mwgk:silent! s/\v +$//<cr>:noh<cr>`w 

" Set newline commands to return to normal mode
nmap o o<Esc>
nmap O O<Esc>

" Write as sudo
cmap w!! %!sudo tee > /dev/null %

" Shortcut to previous file
map <leader><leader> <c-^>

" Shortcut to run current rspec file
map <leader>t :call RunTestFile()<cr>
map <leader>T :call RunNearestTest()<cr>

" Shortcut to run Make
map <leader>ma :!make<cr>

" Resize splits/windows
nnoremap <right>  :3wincmd <<cr>
nnoremap <left> :3wincmd ><cr>
nnoremap <up>    :3wincmd +<cr>
nnoremap <down>  :3wincmd -<cr>

" Emacs bindings in command line mode
cnoremap <c-a> <home>
cnoremap <c-e> <end>

" Open Markdown previews in Marked.app
nnoremap <leader>md :silent !open -a Marked.app '%:p'<cr>

" Make finding marks easier
noremap ' `

" Go to beginning or end of line
nnoremap H ^
nnoremap L g_

" Clear trailing whitespace
nnoremap <leader>w mz:%s/\s\+$//<cr>:let @/=''<cr>`z

" sane movement with wrap turned on
nnoremap <silent> j gj
nnoremap <silent> k gk
vnoremap <silent> j gj
vnoremap <silent> k gk

" Select all
nnoremap vaa ggvGg_
nnoremap Vaa ggVG

" Easier to press
nmap <tab> %
vmap <tab> %

" Reformat line.
nnoremap ql gqq

" Make Y behave like other capitals
nnoremap Y y$

" fix linewise visual selection of various text objects
nnoremap VV V
nnoremap Vit vitVkoj
nnoremap Vat vatV
nnoremap Vab vabV
nnoremap VaB vaBV
nnoremap Va} va}V
nnoremap Vi} vi}V

" made D behave
nnoremap D d$

" Open current file and line on github
nnoremap <leader>gh :call OpenOnGithub('')<cr>

" Open a vsplit
noremap <leader>v <C-w>v

" Show syntax highlighting tokens for token under cursor
map <leader>s :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
\ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
\ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

" Formatting, TextMate-style
nnoremap Q gqip
vnoremap Q gq

" Easy filetype switching {{{
nnoremap _md   :set ft=markdown<CR>
nnoremap _php  :set ft=php<CR>
nnoremap _js   :set ft=javascript<CR>
nnoremap _html :set ft=html<CR>
nnoremap _erb  :set ft=eruby<CR>
nnoremap _rb   :set ft=ruby<CR>
nnoremap _v    :set ft=vim<CR>

" }}}
" Insert Mode Completion {{{
inoremap <c-f> <c-x><c-f>
inoremap <c-]> <c-x><c-]>

" }}}
" BufferOnly {{{

command! -nargs=? -complete=buffer -bang Bonly
    \ :call BufOnly('<args>', '<bang>')

" }}}

" }}}
" Searching and movement -------------------------------------------------- {{{

set ignorecase
set smartcase
set incsearch
set showmatch
set hlsearch
set gdefault

" Centers search results
map N Nzz
map n nzz

" Clear search buffer on return
nnoremap <CR> :nohlsearch<cr>

" }}}
" Folds ------------------------------------------------------------------- {{{

set foldmethod=manual
set nofoldenable

"}}}
" Tags ------------------------------------------------------------------- {{{

set tags=./.git/tags,./tags,tags

"}}}
" Filetype-specific ------------------------------------------------------- {{{

" stwrt.ca blog entries {{{

augroup ft_blog_post
    au!
    au BufRead,BufNewFile */dev/blog/* map ,rt :!hugo &>/dev/null<cr><cr>
augroup END

" }}}
" Clojure {{{

augroup ft_clojure
    au!
    set wildignore+=classes
    set wildignore+=lib
    au Filetype clojure nnoremap <leader>e :Eval<cr>
    au Filetype clojure nnoremap <leader>E :%Eval<cr>
augroup END

" }}}
" ERuby {{{

augroup ft_eruby
    au!
    au Filetype eruby :UltiSnipsAddFiletypes eruby.html
augroup END

" }}}
" SCSS {{{

augroup ft_scss
    au!
    au Filetype scss :UltiSnipsAddFiletypes scss.css
augroup END

" }}}
" Wisp {{{

augroup ft_wisp
    au!
    au BufNewFile,BufRead *.wisp setlocal filetype=clojure
augroup END

" }}}
"
" Pixie {{{

augroup ft_pixie
    au!
    au BufNewFile,BufRead *.pixie,*.pxi setlocal filetype=clojure
augroup END

" }}}
" Javascript {{{

augroup ft_javascript
    au!

    au Filetype javascript nnoremap L :!eslint %<cr>

    au Filetype javascript map <leader>t :!make<cr>

    au BufNewFile,BufRead *.jshintrc setlocal filetype=json

    " Make {<cr> insert a pair of brackets in such a way that the cursor is correctly
    " positioned inside of them AND the following code doesn't get unfolded.
    au Filetype javascript inoremap <buffer> {<cr> {}<left><cr><space><space>.<cr><esc>kA<bs>
augroup END

" }}}
" YAML {{{

augroup ft_yaml
    au!

    au BufNewFile,BufRead *.eslintrc setlocal filetype=yaml
augroup END

" }}}
" Markdown {{{

augroup ft_markdown
    au!

    au BufNewFile,BufRead *.md,*.markdown setlocal filetype=markdown
    au BufNewFile,BufRead *.md,*.markdown setlocal textwidth=0
    au BufNewFile,BufRead *.md,*.markdown setlocal syntax=off

    " Use <localleader>1/2/3 to add headings.
    au Filetype markdown nnoremap <buffer> <localleader>1 yypVr=
    au Filetype markdown nnoremap <buffer> <localleader>2 yypVr-
    au Filetype markdown nnoremap <buffer> <localleader>3 I### <ESC>
augroup END
" }}}
" PHP {{{

augroup ft_php
    au!

    au FileType php,phtml setlocal makeprg=php\ -l\ %
    au FileType php,phtml setlocal errorformat=%m\ in\ %f\ on\ line\ %l
augroup END

" }}}
" Python {{{

augroup ft_python
    au!

    au Filetype python setlocal tabstop=4 shiftwidth=4 softtabstop=4
augroup END

" }}}
" C# {{{

augroup ft_cs
    au!

    au filetype cs setlocal tabstop=4 shiftwidth=4 softtabstop=4 noexpandtab
    au filetype cs setlocal listchars+=tab:\ \ 
augroup END

" }}}
" Elixir {{{

augroup ft_elixir
    au!

    au Filetype elixir map <leader>rt :!mix test<cr>
augroup END

" }}}
" Golang {{{

let g:go_fmt_command = "goimports"

augroup ft_go
    au!

    au Filetype go setlocal tabstop=4 shiftwidth=4 softtabstop=4 noexpandtab
    au Filetype go setlocal listchars+=tab:\ \ 

    " au FileType go au BufWritePre <buffer> GoImports

    au Filetype go nnoremap <leader>d :vsp <CR>:exe "GoDef" <CR>
    au Filetype go nnoremap <leader>rt :exe "GoTest"<cr>
    au Filetype go nnoremap <leader>ru :exe "GoRun"<cr>
    au Filetype go nnoremap <leader>b :exe "GoBuild"<cr>
augroup END

" }}}
" Makefiles {{{

augroup ft_makefile
    au!

    au Filetype make setlocal tabstop=4 shiftwidth=4 softtabstop=4 noexpandtab
    au Filetype make setlocal listchars+=tab:\ \ 
augroup END

" }}}
" C++ {{{

augroup ft_cpp
    au!

    au Filetype cpp setlocal tabstop=4 shiftwidth=4 softtabstop=4 noexpandtab
    au Filetype cpp setlocal listchars+=tab:\ \ 
augroup END

" }}}
" Coffeescript {{{

augroup ft_coffee
    au!

    au Filetype coffee,javascript set path+=./lib,./app/assets/javascripts,./src
augroup END

" }}}
" Ruby {{{

augroup ft_ruby
    au!

    au BufRead,BufNewFile {Capfile,Gemfile,Rakefile,Thorfile,Vagrantfile,config.ru,.caprc,.irbrc} set ft=ruby
    au Filetype ruby setlocal path+=./lib,./app/models,./app/controllers
    au Filetype ruby nnoremap L :!ruby -c %<cr>
augroup END

" }}}
" Vim {{{

augroup ft_vim
    au!

    au FileType vim setlocal textwidth=80
    au FileType help setlocal textwidth=78
    au BufWinEnter *.txt if &ft == 'help' | wincmd L | endif
augroup END

" }}}

" }}}
" Plugin settings --------------------------------------------------------- {{{

" Selecta {{{

" Easier mappings for searches
nnoremap <leader>. :call SelectaTag()<cr>
nnoremap <leader>f :call SelectaFile("")<cr>
nnoremap <leader>gg :call SelectaFileWithoutExclude("")<cr>
nnoremap <leader>gm :call SelectaFile("./app/models/")<cr>
nnoremap <leader>gc :call SelectaFile("./app/controllers/")<cr>
nnoremap <leader>ga :call SelectaFile("./app/assets/")<cr>
nnoremap <leader>gv :call SelectaFile("./app/views/")<cr>
nnoremap <leader>gd :call SelectaFile("./db/")<cr>
nnoremap <leader>gf :call SelectaFile("./features/")<cr>
nnoremap <leader>gl :call SelectaFile("./lib/")<cr>
nnoremap <leader>gs :call SelectaFile("./spec/")<cr>
nnoremap <leader>gt :call SelectaFile("./test/")<cr>
nnoremap <leader>gp :call SelectaFile("./public/")<cr>
nnoremap <leader>b :call SelectaBuffer()<cr>

" }}}
" T-Comment {{{

map <Leader>c <c-_><c-_>

"}}}
" Ultisnips {{{

let g:UltiSnipsExpandTrigger="<s-tab>"
let g:UltiSnipsEditSplit="vertical"

"}}}
" }}}
" Text objects ------------------------------------------------------------ {{{

" Numbers {{{

" Motion for numbers.  Great for CSS.  Lets you do things like this:
"
" margin-top: 200px; -> daN -> margin-top: px;
"              ^                          ^
" TODO: Handle floats.

onoremap N :<c-u>call <SID>NumberTextObject(0)<cr>
xnoremap N :<c-u>call <SID>NumberTextObject(0)<cr>
onoremap aN :<c-u>call <SID>NumberTextObject(1)<cr>
xnoremap aN :<c-u>call <SID>NumberTextObject(1)<cr>
onoremap iN :<c-u>call <SID>NumberTextObject(1)<cr>
xnoremap iN :<c-u>call <SID>NumberTextObject(1)<cr>

function! s:NumberTextObject(whole)
    normal! v

    while getline('.')[col('.')] =~# '\v[0-9]'
        normal! l
    endwhile

    if a:whole
        normal! o

        while col('.') > 1 && getline('.')[col('.') - 2] =~# '\v[0-9]'
            normal! h
        endwhile
    endif
endfunction

" }}}

" }}}
" Functions--------------------------------------------------------- {{{

function! s:CopyMotionForType(type) " {{{
    if a:type ==# 'v'
        silent execute "normal! `<" . a:type . "`>y"
    elseif a:type ==# 'char'
        silent execute "normal! `[v`]y"
    endif
endfunction " }}}
function! BufOnly(buffer, bang) " {{{
  if a:buffer == ''
    " No buffer provided, use the current buffer.
    let buffer = bufnr('%')
  elseif (a:buffer + 0) > 0
    " A buffer number was provided.
    let buffer = bufnr(a:buffer + 0)
  else
    " A buffer name was provided.
    let buffer = bufnr(a:buffer)
  endif

  if buffer == -1
    echohl ErrorMsg
    echomsg "No matching buffer for" a:buffer
    echohl None
    return
  endif

  let last_buffer = bufnr('$')

  let delete_count = 0
  let n = 1
  while n <= last_buffer
    if n != buffer && buflisted(n)
      if a:bang == '' && getbufvar(n, '&modified')
        echohl ErrorMsg
        echomsg 'No write since last change for buffer'
              \ n '(add ! to override)'
        echohl None
      else
        silent exe 'bdel' . a:bang . ' ' . n
        if ! buflisted(n)
          let delete_count = delete_count+1
        endif
      endif
    endif
    let n = n+1
  endwhile

  if delete_count == 1
    echomsg delete_count "buffer deleted"
  elseif delete_count > 1
    echomsg delete_count "buffers deleted"
  endif

endfunction " }}}
function! RenameFile() " {{{
    let old_name = expand('%')
    let new_name = input('New file name: ', expand('%'), 'file')
    if new_name != '' && new_name != old_name
        exec ':saveas ' . new_name
        exec ':silent !rm ' . old_name
        redraw!
    endif
endfunction " }}}
function! SendToFIFO(command) " {{{
" sends command to FIFO living in /tmp
   silent! exec ":!echo '" . a:command . "' > /tmp/fifo"
endfunction " }}}
function! SelectaCommand(choice_command, selecta_args, vim_command) "{{{
" Run a given vim command on the results of fuzzy selecting from a given shell
" command. See usage below.
  try
    let selection = system(a:choice_command . " | selecta " . a:selecta_args)
  catch /Vim:Interrupt/
    " Swallow the ^C so that the redraw below happens; otherwise there will be
    " leftovers from selecta on the screen
    redraw!
    return
  endtry
  redraw!
  exec a:vim_command . " " . selection
endfunction "}}}
function! SelectaFile(dir_name) "{{{
  let command = "find " . a:dir_name . "* -type f -or -type l -maxdepth 15 | egrep -v '^(node_modules|vendor/bundle)' | sort -u"
  call SelectaCommand(command, "", ":e")
endfunction " }}}
function! SelectaFileWithoutExclude(dir_name) "{{{
  let command = "find " . a:dir_name . "* -type f -or -type l -maxdepth 15 | sort -u"
  call SelectaCommand(command, "", ":e")
endfunction " }}}
function! SelectaTag() "{{{
  let command = "awk '{print $1}' tags | sort -u | grep -v '^!'"
  call SelectaCommand(command, "", ":tag")
endfunction " }}}
function! SelectaBuffer() "{{{
  let buffers = map(range(1, bufnr("$")), 'bufname(bufnr(v:val))')
  call SelectaCommand('echo "' . join(buffers, "\n") . '"', "", ":b")
endfunction " }}}
" Opens a link to the current file on GitHub
function! OpenOnGithub(owner)
  let base_url = "https://github.com/"
  let repo = split(getcwd(), "/")[-1] . '/'
  let branch = substitute(system('git rev-parse --abbrev-ref HEAD'), "\n", '', '')
  let filename = '/' . @%
  let line = line('.')
  let owner = a:owner

  if owner == ''
    let owner = substitute(system('whoami'), "\n", '', '')
  end

  silent! exec "!open " . base_url . owner . '/' . repo . "blob/" . branch . filename . shellescape("#L", 1) . line
endfunction
function! RunTestFile(...) " {{{
    if a:0
        let command_suffix = a:1
    else
        let command_suffix = ""
    endif

    " Run the tests for the previously-marked file.
    let in_test_file = match(expand("%"), '\(_spec.rb\|_test.rb\)$') != -1
    if in_test_file
        call SetTestFile()
    elseif !exists("t:current_test_file")
        return
    end
    call RunTests(t:current_test_file . command_suffix)
endfunction " }}}
function! RunNearestTest() " {{{
    if match(expand("%"), '_spec.rb') != -1
        let spec_line_number = line('.')
        call RunTestFile(":" . spec_line_number . " -b")
    else
        call RunTestFile()
    end
endfunction " }}}
function! SetTestFile() " {{{
    " Set the spec file that tests will be run for.
    let t:current_test_file=@%
endfunction " }}}
function! RunTests(filename) " {{{
    " Write the file and run tests for the given filename
    if expand("%") != ""
        :w
    end

    let gemfile_present = filereadable("Gemfile")

    if a:filename == ''
        " no filename provided, so figure out what type of tests we have
        if filereadable("spec/spec_helper.rb")
            if gemfile_present
                let command = ":!bundle exec rspec --color"
            else
                let command = ":!rspec --color"
            end
        else
            if gemfile_present
                let command = ":!bundle exec rake test"
            else
                let command = ":!rake test"
            end
        end
    else
        " we're in a file, so run the relevant test
        if match(a:filename, '_spec.rb') != -1
            if gemfile_present
                let command = ":!bundle exec rspec --color " . a:filename
            else
                let command = ":!rspec --color " . a:filename
            end
        elseif match(a:filename, '_test.rb') != -1
            if gemfile_present
                let command = ":!bundle exec ruby " . a:filename
            else
                let command = ":!ruby " . a:filename
            end
        end
    end

    exec command
endfunction " }}}
function! s:ExecuteInShell(command, bang) " {{{
  let s:_ = ''
  let _ = a:bang != '' ? s:_ : a:command == '' ? '' : join(map(split(a:command), 'expand(v:val)'))

  if (_ != '')
    let s:_ = _
    let bufnr = bufnr('%')
    let winnr = bufwinnr('^' . _ . '$')
    silent! execute  winnr < 0 ? 'botright vnew ' . fnameescape(_) : winnr . 'wincmd w'
    setlocal buftype=nowrite bufhidden=wipe nobuflisted noswapfile
    silent! :%d
    let message = 'Execute ' . _ . '...'
    call append(0, message)
    echo message
    silent! 2d | redraw
    silent! execute 'silent! %!'. _
    silent! execute 'syntax on'
    silent! execute 'autocmd BufUnload <buffer> execute bufwinnr(' . bufnr . ') . ''wincmd w'''
    silent! execute 'nnoremap <silent> <buffer> <CR> :call <SID>ExecuteInShell(''' . _ . ''', '''')<CR>'
    silent! execute 'nnoremap <silent> <buffer> <LocalLeader>r :call <SID>ExecuteInShell(''' . _ . ''', '''')<CR>'
    silent! execute 'nnoremap <silent> <buffer> <LocalLeader>g :execute bufwinnr(' . bufnr . ') . ''wincmd w''<CR>'
    silent! syntax on
  endif
endfunction

command! -complete=shellcmd -nargs=* -bang Shell call s:ExecuteInShell(<q-args>, '<bang>')
cabbrev shell Shell
" }}}

" }}}

" source local vimrc modifications, if present
let s:local_vimrc = $HOME . "/.vimrc.local"
if filereadable(s:local_vimrc)
    execute 'source ' . s:local_vimrc
endif

" Prevent project vimrc files from damaging stuff
set secure
