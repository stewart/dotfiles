" .vimrc
" Author: Andrew Stewart <andrew@averagestudios.com>
" Source: https://github.com/stewart/dotfiles/tree/master/vim

" Preamble ---------------------------------------------------------------- {{{

filetype off
call pathogen#infect()
filetype plugin indent on
set nocompatible

" }}}
" Basic options ----------------------------------------------------------- {{{
"
set autoindent
set smartindent
set autoread
set autowrite
set backspace=indent,eol,start
set backupskip=/tmp/*,/private/tmp/*"
set completeopt=longest,menuone,preview
set clipboard=unnamed
set cursorline
set dictionary=/usr/share/dict/words
set encoding=utf-8
set fillchars=diff:⣿,vert:│
set hidden
set history=1000
set laststatus=2
set lazyredraw
set linebreak
set list
set listchars=tab:▸\ ,trail:⋅,extends:❯,precedes:❮
set matchtime=3
set modelines=0
set noerrorbells
set noshowcmd
set notimeout
set novisualbell
set number
set relativenumber
set ruler
set scrolloff=3
set shiftround
set showbreak=↪
set sidescroll=1
set sidescrolloff=10
set spellfile=~/.vim/custom-dictionary.utf-8.add
set splitbelow
set splitright
set synmaxcol=800
set title
set ttimeout
set ttimeoutlen=10
set ttyfast
set undofile
set undoreload=10000
set virtualedit+=block

" Resize splits when the window is resized
au VimResized * :wincmd =

" Cursorline {{{
" Only show cursorline in the current window and in normal mode.

augroup cline
    au!
    au WinLeave * set nocursorline
    au WinEnter * set cursorline
    au InsertEnter * set nocursorline
    au InsertLeave * set cursorline
augroup END

" }}}
" Wildmenu completion {{{

set wildmenu
set wildmode=list:longest,full

set wildignore+=.hg,.git,.svn
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest
set wildignore+=*.spl
set wildignore+=*.DS_Store

" }}}
"
" Line Return {{{

augroup line_return
    au!
    au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \     execute 'normal! g`"zvzz' |
        \ endif
augroup END

" }}}
" Tabs, spaces, wrapping {{{

set tabstop=2
set shiftwidth=2
set softtabstop=2
set expandtab
set nosmarttab
set textwidth=80
set formatoptions=qrn1
set wrap
set whichwrap+=<,>,h,l,[,]      " backspace and cursor keys wrap to

" }}}
" Relative Line Numbers in Current Buffer {{{

if exists('&relativenumber')
  set relativenumber
  augroup WindowRNU
    auto!
    auto BufWinEnter,WinEnter,FocusGained * setlocal relativenumber
    auto WinLeave,FocusLost               * setlocal number
  augroup END
endif

" }}}
" Backups {{{

set undodir=~/.vim/tmp/undo//
set backupdir=~/.vim/tmp/backup//
set directory=~/.vim/tmp/swap//
set backup
set noswapfile

" }}}
" Leader {{{

let mapleader = ","
let maplocalleader = "\\"

" }}}
" Colorscheme Font, and Guioptions {{{

colorscheme solarized
let g:solarized_termcolors=16
set background=dark
set guifont=Inconsolata-dz\ for\ PowerLine:h12
set guioptions-=T
set guioptions-=m
set guioptions=aAce
syntax on

" }}}
"
" }}}
" Convenience mappings ---------------------------------------------------- {{{

" Kill window
nnoremap K :q<cr>

" Change window splits easily
map <C-J> <C-w><C-j>
map <C-K> <C-w><C-k>
map <C-h> <C-w><C-h>
map <C-l> <C-w><C-l>
" exit to normal mode with 'jj'
inoremap jj <ESC>

" gundo
nnoremap <Leader>u :GundoToggle<CR>

" yankring
nnoremap <silent> <Leader>y :YRShow<CR>

" change case
inoremap <C-u> <esc>mzgUiw`za

" keep the cursor in place while joining lines
nnoremap J mzJ`z

" split line
nnoremap S i<cr><esc>^mwgk:silent! s/\v +$//<cr>:noh<cr>`w

" move the current line front and center
nnoremap <c-z> zvzz

" ; acts as : in normal mode:
nmap ; :

" Set newline commands to return to insert mode
nmap o o<Esc>
nmap O O<Esc>

" Change window splits easily
map <C-J> <C-w><C-j>
map <C-K> <C-w><C-k>
map <C-h> <C-w><C-h>
map <C-l> <C-w><C-l>

" Shortcut for T-Comment
map <Leader>c <c-_><c-_>

" Write as sudo
cmap w!! %!sudo tee > /dev/null %

" Use space key to toggle folds
nnoremap <Space> za
vnoremap <Space> za

" Make find/replace easier
nnoremap <leader>s :%s//<left>

" Emacs bindings in command line mode
cnoremap <c-a> <home>
cnoremap <c-e> <end>

" Open Markdown previews in Marked.app
nnoremap <leader>m :silent !open -a Marked.app '%:p'<cr>

" Charwise selection
nnoremap vv ^vg_

" Make finding marks easier
noremap ' `

" Insert mode completion
inoremap <c-l> <c-x><c-l>
inoremap <c-f> <c-x><c-f>

" Go to beginning or end of line
nnoremap H ^
nnoremap L g_

" Clear trailing whitespace
nnoremap <leader>w mz:%s/\s\+$//<cr>:let @/=''<cr>`z

" sane movement with wrap turned on
nnoremap <silent> j gj
nnoremap <silent> k gk
vnoremap <silent> j gj
vnoremap <silent> k gk

" Alternate between two and four space indentation
nnoremap <leader>2 :setlocal shiftwidth=2 tabstop=2 softtabstop=2<cr>
nnoremap <leader>4 :setlocal shiftwidth=4 tabstop=4 softtabstop=4<cr>

" Select all
nnoremap <leader>A ggVG

" Easier to press
nnoremap <tab> %

nnoremap <C-[> :tabprevious<CR>
nnoremap <C-]> :tabnext<CR>
nnoremap <C-t> :tabnew<CR>

map <leader>rf :call RenameFile()<cr>

" Make Y behave like other capitals
nnoremap Y y$

" fix linewise visual selection of various text objects
nnoremap VV V
nnoremap Vit vitVkoj
nnoremap Vat vatV
nnoremap Vab vabV
nnoremap VaB vaBV

" made D behave
nnoremap D d$

noremap <leader>v <C-w>v

" Formatting, TextMate-style
nnoremap Q gqip
vnoremap Q gq

" numbers as objects
onoremap N :<c-u>call <SID>NumberTextObject(0)<cr>
xnoremap N :<c-u>call <SID>NumberTextObject(0)<cr>
onoremap aN :<c-u>call <SID>NumberTextObject(1)<cr>
xnoremap aN :<c-u>call <SID>NumberTextObject(1)<cr>
onoremap iN :<c-u>call <SID>NumberTextObject(1)<cr>
xnoremap iN :<c-u>call <SID>NumberTextObject(1)<cr>

nnoremap <silent> <leader>a :set opfunc=<SID>AckMotion<CR>g@
xnoremap <silent> <leader>a :<C-U>call <SID>AckMotion(visualmode())<CR>

" Easy filetype switching {{{

nnoremap _md   :set ft=markdown<CR>
nnoremap _php  :set ft=php<CR>
nnoremap _js   :set ft=javascript<CR>
nnoremap _html :set ft=html<CR>
nnoremap _erb  :set ft=eruby<CR>
nnoremap _rb   :set ft=ruby<CR>
nnoremap _v    :set ft=vim<CR>

" }}}
" Insert Mode Completion {{{

inoremap <c-f> <c-x><c-f>
inoremap <c-]> <c-x><c-]>

" }}}
" BufferOnly {{{

command! -nargs=? -complete=buffer -bang Bonly
    \ :call BufOnly('<args>', '<bang>')
command! -nargs=? -complete=buffer -bang BOnly
    \ :call BufOnly('<args>', '<bang>')
command! -nargs=? -complete=buffer -bang Bufonly
    \ :call BufOnly('<args>', '<bang>')
command! -nargs=? -complete=buffer -bang BufOnly
    \ :call BufOnly('<args>', '<bang>')

" }}}

" }}}
" Quick editing ----------------------------------------------------------- {{{

nnoremap <leader>ev :vsplit $MYVIMRC<cr>
nnoremap <leader>ed :vsplit ~/.vim/custom-dictionary.utf-8.add<cr>
nnoremap <leader>eg :vsplit ~/.gitconfig<cr>
nnoremap <leader>ez :vsplit ~/.zshrc<cr>
nnoremap <leader>et :vsplit ~/.tmux.conf<cr>

" }}}
" Searching and movement -------------------------------------------------- {{{

set ignorecase
set smartcase
set incsearch
set showmatch
set hlsearch
set gdefault

" Centers search results
map N Nzz
map n nzz

" Clear search buffer on return
nnoremap <CR> :nohlsearch<cr>

" }}}
" Folding ----------------------------------------------------------------- {{{

set foldlevelstart=0

" Space to toggle folds.
nnoremap <Space> za
vnoremap <Space> za

" "Refocus" folds
nnoremap ,z zMzvzz

" Make zO recursively open whatever top level fold we're in, no matter where the
" cursor happens to be.
nnoremap zO zCzO

function! MyFoldText() " {{{
    let line = getline(v:foldstart)

    let nucolwidth = &fdc + &number * &numberwidth
    let windowwidth = winwidth(0) - nucolwidth - 3
    let foldedlinecount = v:foldend - v:foldstart

    " expand tabs into spaces
    let onetab = strpart('          ', 0, &tabstop)
    let line = substitute(line, '\t', onetab, 'g')

    let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
    let fillcharcount = windowwidth - len(line) - len(foldedlinecount)
    return line . '…' . repeat(" ",fillcharcount) . foldedlinecount . '…' . ' '
endfunction " }}}
set foldtext=MyFoldText()

" }}}
" Filetype-specific ------------------------------------------------------- {{{

" Javascript {{{

augroup ft_javascript
    au!

    au FileType javascript setlocal foldmethod=marker
    au FileType javascript setlocal foldmarker={,}

    " Make {<cr> insert a pair of brackets in such a way that the cursor is correctly
    " positioned inside of them AND the following code doesn't get unfolded.
    au Filetype javascript inoremap <buffer> {<cr> {}<left><cr><space><space>.<cr><esc>kA<bs>
augroup END

" }}}
" Markdown {{{

augroup ft_markdown
    au!

    au BufNewFile,BufRead *.md,*.markdown setlocal filetype=markdown
    au BufNewFile,BufRead *.md,*.markdown setlocal textwidth=80

    " Use <localleader>1/2/3 to add headings.
    au Filetype markdown nnoremap <buffer> <localleader>1 yypVr=
    au Filetype markdown nnoremap <buffer> <localleader>2 yypVr-
    au Filetype markdown nnoremap <buffer> <localleader>3 I### <ESC>
augroup END
" }}}
" Vim {{{

augroup ft_vim
    au!

    au FileType vim setlocal foldmethod=marker
    au FileType vim setlocal textwidth=80
    au FileType help setlocal textwidth=78
    au BufWinEnter *.txt if &ft == 'help' | wincmd L | endif
augroup END

" }}}
" PHP {{{

augroup ft_php
    au!

    au FileType php,phtml setlocal foldmethod=marker
    au FileType php,phtml setlocal foldmarker={,}
augroup END

" }}}
" CSS {{{

augroup ft_css
    au!

    au FileType css setlocal foldmethod=marker
    au FileType css setlocal foldmarker={,}
augroup END

" }}}

" }}}
" Plugin settings --------------------------------------------------------- {{{

" Ack {{{

nnoremap <leader>a :Ack!<space>
nnoremap <silent> <leader>a :set opfunc=<SID>AckMotion<CR>g@
xnoremap <silent> <leader>a :<C-U>call <SID>AckMotion(visualmode())<CR>

" }}}
" Ctrl-P {{{

let g:ctrlp_dont_split = 'NERD_tree_2'
let g:ctrlp_jump_to_buffer = 0
let g:ctrlp_map = '<Leader>t'
let g:ctrlp_max_files = 10000
let g:ctrlp_working_path_mode = 0
let g:ctrlp_match_window_reversed = 1
let g:ctrlp_split_window = 0
let g:ctrlp_max_height = 20
let g:ctrlp_extensions = ['tag']

let g:ctrlp_prompt_mappings = {
\ 'PrtSelectMove("j")':   ['<c-j>', '<down>', '<s-tab>'],
\ 'PrtSelectMove("k")':   ['<c-k>', '<up>', '<tab>'],
\ 'PrtHistory(-1)':       ['<c-n>'],
\ 'PrtHistory(1)':        ['<c-p>'],
\ 'ToggleFocus()':        ['<c-tab>'],
\ }

let ctrlp_filter_greps = "".
    \ "egrep -iv '\\.(" .
    \ "jar|class|swp|swo|log|so|o|pyc|jpe?g|png|gif|mo|po" .
    \ ")$' | " .
    \ "egrep -v '^(\\./)?(" .
    \ "deploy/|lib/|classes/|libs/|deploy/vendor/|.git/|.hg/|.svn/|.*migrations/" .
    \ ")'"

let my_ctrlp_user_command = "" .
    \ "find %s '(' -type f -or -type l ')' -maxdepth 15 -not -path '*/\\.*/*' | " .
    \ ctrlp_filter_greps

let my_ctrlp_git_command = "" .
    \ "cd %s && git ls-files | " .
    \ ctrlp_filter_greps

let g:ctrlp_user_command = ['.git/', my_ctrlp_git_command, my_ctrlp_user_command]

" }}}
" NERDTree {{{

map <Leader>n :NERDTree<CR>

let NERDTreeHighlightCursorline = 1
let NERDTreeIgnore = ['.vim$', '\~$', '.*\.pyc$', 'pip-log\.txt$', 'whoosh_index',
                    \ 'xapian_index', '.*.pid', 'monitor.py', '.*-fixtures-.*.json',
                    \ '.*\.o$', 'db.db', 'tags.bak']

let NERDTreeShowHidden=0
let NERDTreeIgnore=['\.rbc$', '\~$']
let NERDTreeMinimalUI = 1
let NERDTreeDirArrows = 1
let NERDChristmasTree = 1

" }}}
" LustyJuggler {{{

let g:LustyJugglerAltTabMode = 1
let g:LustyJugglerSuppressRubyWarning = 1
noremap <silent> <Leader><Tab> :LustyJuggler<CR>

" }}}
" Powerline {{{

let g:Powerline_symbols = 'fancy'
let g:Powerline_cache_enabled = 1

" }}}
" Supertab {{{

let g:SuperTabDefaultCompletionType = "<c-n>"
let g:SuperTabLongestHighlight = 1
let g:SuperTabCrMapping = 1

"}}}
" YankRing {{{

let g:yankring_max_history = 1000

"}}}

" }}}
" Functions--------------------------------------------------------- {{{

function! s:CopyMotionForType(type) " {{{
    if a:type ==# 'v'
        silent execute "normal! `<" . a:type . "`>y"
    elseif a:type ==# 'char'
        silent execute "normal! `[v`]y"
    endif
endfunction " }}}

function! s:AckMotion(type) abort " {{{
    let reg_save = @@

    call s:CopyMotionForType(a:type)

    execute "normal! :Ack! --literal " . shellescape(@@) . "\<cr>"

    let @@ = reg_save
endfunction " }}}

function! s:NumberTextObject(whole) " {{{
    normal! v

    while getline('.')[col('.')] =~# '\v[0-9]'
        normal! l
    endwhile

    if a:whole
        normal! o

        while col('.') > 1 && getline('.')[col('.') - 2] =~# '\v[0-9]'
            normal! h
        endwhile
    endif
endfunction " }}}

function! BufOnly(buffer, bang) " {{{
  if a:buffer == ''
    " No buffer provided, use the current buffer.
    let buffer = bufnr('%')
  elseif (a:buffer + 0) > 0
    " A buffer number was provided.
    let buffer = bufnr(a:buffer + 0)
  else
    " A buffer name was provided.
    let buffer = bufnr(a:buffer)
  endif

  if buffer == -1
    echohl ErrorMsg
    echomsg "No matching buffer for" a:buffer
    echohl None
    return
  endif

  let last_buffer = bufnr('$')

  let delete_count = 0
  let n = 1
  while n <= last_buffer
    if n != buffer && buflisted(n)
      if a:bang == '' && getbufvar(n, '&modified')
        echohl ErrorMsg
        echomsg 'No write since last change for buffer'
              \ n '(add ! to override)'
        echohl None
      else
        silent exe 'bdel' . a:bang . ' ' . n
        if ! buflisted(n)
          let delete_count = delete_count+1
        endif
      endif
    endif
    let n = n+1
  endwhile

  if delete_count == 1
    echomsg delete_count "buffer deleted"
  elseif delete_count > 1
    echomsg delete_count "buffers deleted"
  endif

endfunction " }}}

" }}}
